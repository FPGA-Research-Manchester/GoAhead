using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using GoAhead.Code.VHDL;
using GoAhead.Commands.CommandExecutionSettings;
using GoAhead.Commands.Data;
using GoAhead.Commands.Library;
using GoAhead.Commands.NetlistContainerGeneration;
using GoAhead.Commands.Selection;
using GoAhead.Commands.UCF;
using GoAhead.Commands.VHDL;
using GoAhead.Commands.XDLManipulation;
using GoAhead.Objects;

namespace GoAhead.Commands.Wizards
{
    public class BuildIslandStyleModule : Command
    {
        protected override void DoCommandAction()
        {
            string partialScript = ProjectDirectory + Path.DirectorySeparatorChar + "partial.goa";
            string extractScript = ProjectDirectory + Path.DirectorySeparatorChar + "extract_modules.goa";
            string loadModules = ProjectDirectory + Path.DirectorySeparatorChar + "load_modules.goa";

            TextWriter goaScript = new StreamWriter(partialScript, false);
            goaScript.WriteLine("# " + goaScript + " for building a partial module. Generated by GoAhead");

            goaScript.WriteLine("##############################################################################");
            goaScript.WriteLine("# load device and build module library ");
            goaScript.WriteLine("##############################################################################");

            goaScript.WriteLine("# open the device description");
            goaScript.WriteLine(Blackboard.Instance.LastLoadCommandForFPGA);

            goaScript.WriteLine("");
            MuteOutput muteCmd = new MuteOutput();
            muteCmd.Comment = "for readability we will mute the VHDL and UCF outputs to the console";
            goaScript.WriteLine(muteCmd.ToString());

            goaScript.WriteLine("##############################################################################");
            goaScript.WriteLine("# print instantiations of static placeholders and modules");
            goaScript.WriteLine("##############################################################################");

            goaScript.WriteLine("# therefore open the interface description for the partial areas ");
            foreach (string loadCommand in Objects.InterfaceManager.Instance.LoadCommands)
            {
                goaScript.WriteLine(loadCommand);
            }

            PrintArchitectureWithStaticPlaceholderInstantiation printArchCmd = new PrintArchitectureWithStaticPlaceholderInstantiation();
            printArchCmd.Append = false;
            printArchCmd.FileName = TopVHDLFile;
            printArchCmd.PartialAreaNames = PartialAreas;
            printArchCmd.Comment = "create or overwrite a VHDL with an architecture for each partial area connected with each module";
            goaScript.WriteLine(printArchCmd.ToString());

            bool firstComplDecl = true;
            List<string> vhdlModules = new List<string>();
            foreach (string partialArea in PartialAreas)
            {
                foreach (string vhdlModule in GetVHDLFilePaths(partialArea))
                {
                    if (!vhdlModules.Contains(vhdlModule))
                    {
                        vhdlModules.Add(vhdlModule);
                    }
                }
            }

            foreach (string vhdlModule in vhdlModules)
            {
                PrintComponentDeclarationForVHDLModule printCompDecl = new PrintComponentDeclarationForVHDLModule();
                printCompDecl.Append = true;
                printCompDecl.FileName = TopVHDLFile;
                printCompDecl.VHDLModule = vhdlModule;
                printCompDecl.Comment = firstComplDecl ? "print the component declaration of for all partial modules" : "";
                goaScript.WriteLine(printCompDecl.ToString());
                firstComplDecl = false;
            }

            bool firstSignallDecl = true;
            foreach (string partialArea in PartialAreas)
            {
                foreach (string vhdlModule in GetVHDLFilePaths(partialArea))
                {
                    PrintWireDeclarationForSignalMapping printSignalDecl = new PrintWireDeclarationForSignalMapping();
                    printSignalDecl.Append = true;
                    printSignalDecl.FileName = TopVHDLFile;
                    printSignalDecl.PartialAreaName = partialArea;
                    printSignalDecl.VHDLModule = vhdlModule;
                    printSignalDecl.PrintAttributeDeclaration = firstSignallDecl;
                    printSignalDecl.Comment = firstSignallDecl ? "declare signals to connect module " : "";
                    goaScript.WriteLine(printSignalDecl.ToString());
                    firstSignallDecl = false;
                }
            }

            bool firstConditionalInstantiation = true;
            List<PrintConditionalModuleInstantiation> printCondInstCmds = new List<PrintConditionalModuleInstantiation>();
            foreach (string partialArea in PartialAreas)
            {
                foreach (string vhdlModule in GetVHDLFilePaths(partialArea))
                {
                    PrintConditionalModuleInstantiation printCondInst = new PrintConditionalModuleInstantiation();
                    printCondInst.Append = true;
                    printCondInst.PrintBegin = firstConditionalInstantiation;
                    printCondInst.CloseArchitecture = false;
                    printCondInst.FileName = TopVHDLFile;
                    printCondInst.PartialAreaName = partialArea;
                    printCondInst.VHDLModule = vhdlModule;
                    printCondInst.Comment = firstConditionalInstantiation ? "conditionally instantiate modules and placeholder and connect them" : "";
                    printCondInstCmds.Add(printCondInst);
                    firstConditionalInstantiation = false;
                }
            }
            if (printCondInstCmds.Count > 0)
            {
                printCondInstCmds[printCondInstCmds.Count - 1].CloseArchitecture = true;
            }
            foreach (Command cmd in printCondInstCmds)
            {
                goaScript.WriteLine(cmd.ToString());
            }

            PrintModuleSelectionPackage printConfigPackage = new PrintModuleSelectionPackage();
            printConfigPackage.Append = false;
            printConfigPackage.FileName = ProjectDirectory + Path.DirectorySeparatorChar + "config.vhd";
            printConfigPackage.PartialAreaNames = PartialAreas;
            printConfigPackage.ModulesPerArea = ModulesPerArea;
            printConfigPackage.Comment = "create or overwrite a VHDL package with a single constant that will selected which module will be instantiated";
            goaScript.WriteLine(printConfigPackage.ToString());

            // trunc in first run
            bool appendToBatchFile = false;
            for (int i = 0; i < PartialAreas.Count; i++)
            {
                string partialAreaName = PartialAreas[i];

                // only consider those partial areas in which we build modules in
                if (!ModulesPerArea.Any(s => s.StartsWith(partialAreaName)))
                {
                    continue;
                }

                string moduleBlocker = ProjectDirectory + Path.DirectorySeparatorChar + partialAreaName + "_blocker.xdl";

                IslandCommandBuilder builder = new IslandCommandBuilder();
                builder.IslandName = PartialAreas[i];
                builder.VHDLWrapper = VHDLWrapper[i];
                builder.UCFFile = ProjectDirectory + Path.DirectorySeparatorChar + partialAreaName + ".ucf";
                builder.ConnectionPrimitiveName = ConnectionPrimitives[i];
                builder.BuildTarget = IslandCommandBuilder.Target.Module;

                goaScript.WriteLine("##############################################################################");
                goaScript.WriteLine("# GOA Commands for the partial area " + builder.IslandName);
                goaScript.WriteLine("##############################################################################");

                Reset resetCmd = new Reset();
                resetCmd.Comment = "run a reset to release previous blocked routing resources and slices";
                goaScript.WriteLine(resetCmd.ToString());

                goaScript.WriteLine("# open the interface description for the partial areas (restore after reset)");
                foreach (string loadCommand in Objects.InterfaceManager.Instance.LoadCommands.Where(s => s.Contains("PartialArea=" + partialAreaName)))
                {
                    goaScript.WriteLine(loadCommand);
                }

                // there might be several forms using the same macro, however the macro may only be read in once per script
                // therefore we pull the macro from the ctrl
                goaScript.WriteLine("# load one or more connection primitives (the reset cleared the macro library)");
                List<string> macros = new List<string>();
                foreach (string connectionPrimitives in ConnectionPrimitives)
                {
                    if (!macros.Contains(connectionPrimitives))
                    {
                        LibraryElement libElement = Objects.Library.Instance.GetElement(connectionPrimitives);
                        goaScript.WriteLine(libElement.LoadCommand);
                        macros.Add(connectionPrimitives);
                    }
                }

                List<string> blocker = new List<string>();

                // the first PrintLocationConstraintsForPlacedMacros must run with Append=false to overwrite
                bool printLocCmdFound = false;
                foreach (Command cmd in builder.GetCommands())
                {
                    // make sure the first UCF command overwrites or creates a file
                    if (!printLocCmdFound && cmd is UCFCommand)
                    {
                        ((UCFCommand)cmd).Append = false;
                        ((UCFCommand)cmd).Comment += ". this command will truncate the UCF file";
                        printLocCmdFound = true;
                    }
                    // capture the maco name
                    if (cmd is AddNetlistContainer)
                    {
                        blocker.Add(((AddNetlistContainer)cmd).NetlistContainerName);
                    }
                    // dump command to file
                    goaScript.WriteLine(cmd.ToString());
                }

                // generate a global blocker for each partial region
                GenerateXDL genBlocker = new GenerateXDL();
                genBlocker.FileName = moduleBlocker;
                genBlocker.NetlistContainerNames = blocker;
                genBlocker.IncludePorts = false;
                genBlocker.IncludeDummyNets = true;
                genBlocker.IncludeModuleHeader = false;
                genBlocker.IncludeModuleFooter = false;
                genBlocker.Comment = "save the blocker for routing to an XDL file";
                goaScript.WriteLine(genBlocker.ToString());

                genBlocker.FileName = Regex.Replace(moduleBlocker, @"\.xdl", "_FE.xdl"); ;
                genBlocker.IncludeModuleHeader = true;
                genBlocker.IncludeModuleFooter = true;
                genBlocker.IncludeDesignStatement = true;
                genBlocker.Comment = "save the blocker for conversion with xdl -xdl2ncd " + genBlocker.FileName + " -nodrc";
                goaScript.WriteLine(genBlocker.ToString());

                if (ModulesPerArea.Any(s => s.StartsWith(partialAreaName)))
                {
                    BuildIslandStyleModuleRunBatch genBatchCmd = new BuildIslandStyleModuleRunBatch();
                    genBatchCmd.FileName = ProjectDirectory + Path.DirectorySeparatorChar + "create_bitstreams.bat";
                    genBatchCmd.Append = appendToBatchFile;
                    genBatchCmd.VHDLModules = ModulesPerArea.Where(s => s.StartsWith(partialAreaName)).ToList();
                    genBatchCmd.Comment = "create a batch file that generates all module bitstreams";
                    goaScript.WriteLine(genBatchCmd.ToString());
                    appendToBatchFile = true;
                }
            }

            goaScript.Close();

            ////////////
            // extract
            TextWriter extractScriptFile = new StreamWriter(extractScript, false);
            extractScriptFile.WriteLine("# " + extractScript + " for extracting the partial modules. Generated by GoAhead");
            extractScriptFile.WriteLine(Blackboard.Instance.LastLoadCommandForFPGA);

            for (int i = 0; i < PartialAreas.Count; i++)
            {
                foreach (string entityName in GetEntities(PartialAreas[i]))
                {
                    string moduleXDL = PartialAreas[i] + entityName + ".xdl";
                    string moduleBin = PartialAreas[i] + entityName + ".bin";

                    ClearSelection clearSel = new ClearSelection();
                    clearSel.Comment = "clear the current selection and select the module shape for module " + entityName + " in area " + PartialAreas[i];
                    extractScriptFile.WriteLine(clearSel.ToString());
                    foreach (Command sel in FPGA.TileSelectionManager.Instance.GetListOfAddToSelectionXYCommandsForUserSelection(PartialAreas[i]))
                    {
                        extractScriptFile.WriteLine(sel.ToString());
                    }

                    ExtractModule extractCmd = new ExtractModule();
                    extractCmd.Comment = "cut out the current selection and store the module " + entityName + " in area " + PartialAreas[i];
                    extractCmd.BinaryNetlist = moduleBin;
                    // overwrite
                    extractCmd.XDLInFile = moduleXDL;
                    extractCmd.XDLOutFile = moduleXDL;
                    extractScriptFile.WriteLine(extractCmd.ToString());
                }
            }
            extractScriptFile.Close();

            //////////
            // load

            TextWriter loadScriptFile = new StreamWriter(loadModules, false);
            loadScriptFile.WriteLine("# " + extractScript + " for instantiating the partial modules. Generated by GoAhead");
            loadScriptFile.WriteLine(Blackboard.Instance.LastLoadCommandForFPGA);

            OpenDesign openStaticDesign = new OpenDesign();
            openStaticDesign.Comment = "read in the static design";
            openStaticDesign.FileName = "static.xdl";
            loadScriptFile.WriteLine(openStaticDesign);

            for (int i = 0; i < PartialAreas.Count; i++)
            {
                ClearSelection clearSel = new ClearSelection();
                loadScriptFile.WriteLine(clearSel.ToString());

                foreach (Command sel in FPGA.TileSelectionManager.Instance.GetListOfAddToSelectionXYCommandsForUserSelection(PartialAreas[i]))
                {
                    loadScriptFile.WriteLine(sel.ToString());
                }

                CutOff cutOffCmd = new CutOff();
                loadScriptFile.WriteLine(cutOffCmd);

                StoreCurrentSelectionAs storeCmd = new StoreCurrentSelectionAs();
                storeCmd.UserSelectionType = PartialAreas[i];
                loadScriptFile.WriteLine(storeCmd.ToString());
            }

            for (int i = 0; i < PartialAreas.Count; i++)
            {
                foreach (string entityName in GetEntities(PartialAreas[i]))
                {
                    AddBinaryLibraryElement addCmd = new AddBinaryLibraryElement();
                    addCmd.Comment = "load the module";
                    addCmd.FileName = PartialAreas[i] + entityName + ".bin";
                    loadScriptFile.WriteLine(addCmd.ToString());
                }
            }

            loadScriptFile.WriteLine("ShowGUI;");

            loadScriptFile.Close();
        }

        private IEnumerable<string> GetEntities(string partialArea)
        {
            foreach (string mapping in ModulesPerArea.Where(str => str.StartsWith(partialArea + ":")))
            {
                string[] tupel = Regex.Split(mapping, partialArea + ":");
                VHDLParser vhdlParser = new VHDLParser(tupel[1]);
                foreach (VHDLParserEntity ent in vhdlParser.GetEntities())
                {
                    yield return ent.EntityName;
                }
            }
        }

        private IEnumerable<string> GetVHDLFilePaths(string partialArea)
        {
            foreach (string mapping in ModulesPerArea.Where(str => str.StartsWith(partialArea + ":")))
            {
                string[] tupel = Regex.Split(mapping, partialArea + ":");
                yield return tupel[1];
            }
        }

        public override void Undo()
        {
            throw new NotImplementedException();
        }

        [Parameter(Comment = "The directory in which to save generated scripts")]
        public string ProjectDirectory = "";

        [Parameter(Comment = "A list of partial areas (user selections")]
        public List<string> PartialAreas = new List<string>();

        [Parameter(Comment = @"pr0:c:\temp\m1.vhd,pr0:c:\temp\m2.vhd,pr1:c:\temp\m3.vhd")]
        public List<string> ModulesPerArea = new List<string>();

        [Parameter(Comment = "A list of connections macro (one for each partial area")]
        public List<string> ConnectionPrimitives = new List<string>();

        [Parameter(Comment = "")]
        public string TopVHDLFile = "top.vhd";

        [Parameter(Comment = "A list of VHDL files (one for each partial area")]
        public List<string> VHDLWrapper = new List<string>();
    }
}