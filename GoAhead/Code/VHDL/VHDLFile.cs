using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using GoAhead.Objects;

namespace GoAhead.Code.VHDL
{
    public class VHDLFile
    {
        public VHDLFile(string name)
        {
            m_name = name;
            m_entity = new VHDLEntity();
        }

        public void Add(VHDLComponent component)
        {
            m_components.Add(component);
        }

        public bool HasComponent(string componentName)
        {
            return m_components.FirstOrDefault(c => c.Name.Equals(componentName)) != null;
        }

        public void Add(VHDLInstantiation instantiation)
        {
            m_instantiation.Add(instantiation);
        }

        public VHDLEntity Entity
        {
            get { return m_entity; }
        }

        public VHDLSignalDeclaration SignalDeclaration
        {
            get { return m_signalDeclaration; }
        }

        public string GetSubsystem(bool printComponentDeclaration)
        {
            StringBuilder buffer = new StringBuilder();

            buffer.AppendLine("-- This file was automatically generated by GoAhead");
            buffer.AppendLine("");
            buffer.AppendLine("-- Normally, there is no need for modifying this file.");
            buffer.AppendLine("-- However, there are comments with the keywords \"architecture_declaration\" ");
            buffer.AppendLine("-- and \"architecture_body\" that easily allow adding extra code to this file");
            buffer.AppendLine("-- Example for adding \"internal_signal_a <= internal_signal_b\" to the body of your_file.vhd:");
            buffer.AppendLine("-- cat your_file.vhd | sed 's/-- architecture_body/internal_signal_a := internal_signal_b;/g' | tr \":\" \"<\" > out.vhd");
            buffer.AppendLine("-- Note that we use \":=\" instead of \"<=\", which is corrected by tr (translate)");
            buffer.AppendLine("");
            buffer.AppendLine("----------------------------------------------------------------");
            buffer.AppendLine("");

            buffer.AppendLine("library IEEE;");
            buffer.AppendLine("use IEEE.STD_LOGIC_1164.ALL;");
            buffer.AppendLine("");
            // in Vivado, we use LUTs as connection primitives
            if (FPGA.FPGA.Instance.BackendType == FPGA.FPGATypes.BackendType.Vivado)
            {
                buffer.AppendLine("library UNISIM;");
                buffer.AppendLine("use UNISIM.VComponents.all;");
                buffer.AppendLine("");
            }

            buffer.AppendLine("entity " + m_name + " is port (");
            buffer.AppendLine(Entity.ToString());
            buffer.AppendLine("end " + m_name + ";");
            buffer.AppendLine("");
            buffer.AppendLine("architecture Behavioral of " + m_name + " is");
            buffer.AppendLine("");
            buffer.AppendLine("-- architecture_declaration");
            buffer.AppendLine("");
            buffer.AppendLine("attribute s : string;");
            buffer.AppendLine("attribute keep : string;");
            buffer.AppendLine("");
            // prevent two blank lines in no signals are required
            if (!string.IsNullOrEmpty(m_signalDeclaration.ToString()))
            {
                buffer.Append(m_signalDeclaration.ToString());
                buffer.AppendLine("");
            }

            if (printComponentDeclaration)
            {
                foreach (VHDLComponent comp in m_components)
                {
                    buffer.Append(comp.ToString());
                    buffer.AppendLine("");
                }
            }

            buffer.AppendLine("begin");
            buffer.AppendLine("");
            buffer.AppendLine("-- architecture_body");
            buffer.AppendLine("");

            foreach (VHDLInstantiation inst in m_instantiation)
            {
                buffer.Append(inst.ToString());
                buffer.AppendLine("");
            }

            buffer.AppendLine("end architecture Behavioral;");

            return buffer.ToString();
        }

        public string GetSubsystemInstantiation()
        {
            StringBuilder buffer = new StringBuilder();
            buffer.AppendLine("-- This file was automatically generated by GoAhead");
            buffer.AppendLine("");
            buffer.AppendLine("-- component_declaration");
            buffer.AppendLine("component " + m_name + " is port (");
            buffer.Append(Entity.ToString());
            buffer.AppendLine("end component " + m_name + ";");
            buffer.AppendLine("");
            buffer.AppendLine("-- attribute_declaration");
            buffer.AppendLine("attribute s : string;");
            buffer.AppendLine("attribute keep : string;");
            buffer.AppendLine("-- signal_declaration");
            foreach (Tuple<string, int> s in Entity.GetSignals())
            {
                PortMapper.MappingKind mapping = Entity.HasMapping(s.Item1) ? Entity.GetMapping(s.Item1) : PortMapper.MappingKind.External;
                switch (mapping)
                {
                    case PortMapper.MappingKind.NoVector:
                        buffer.AppendLine("signal " + s.Item1 + " : std_logic := '1';");
                        break;

                    case PortMapper.MappingKind.Internal:
                    case PortMapper.MappingKind.External:
                        buffer.AppendLine("signal " + s.Item1 + " : std_logic_vector(" + (s.Item2 - 1) + " downto 0) := (others => '1');");
                        break;

                    default:
                        break;
                }
            }
            buffer.AppendLine("-- attribute_assignment");
            foreach (Tuple<string, int> s in Entity.GetSignals())
            {
                buffer.AppendLine("attribute s of " + s.Item1 + " : signal is \"true\";");
            }
            foreach (Tuple<string, int> s in Entity.GetSignals())
            {
                buffer.AppendLine("attribute keep of " + s.Item1 + " : signal is \"true\";");
            }
            buffer.AppendLine("");
            buffer.AppendLine("-- instantiation_code");
            buffer.AppendLine("inst_" + m_name + " : " + m_name);
            buffer.AppendLine("port map (");

            List<string> assignments = new List<string>();
            foreach (Tuple<string, int> s in Entity.GetSignals())
            {
                assignments.Add("\t" + s.Item1 + " => " + s.Item1 + ",");
            }
            if (assignments.Count > 0)
            {
                assignments[assignments.Count - 1] = Regex.Replace(assignments[assignments.Count - 1], ",", "");
            }
            foreach (string a in assignments)
            {
                buffer.AppendLine(a);
            }

            buffer.AppendLine(");");

            return buffer.ToString();
        }

        private readonly string m_name;
        private readonly VHDLEntity m_entity;
        private readonly VHDLSignalDeclaration m_signalDeclaration = new VHDLSignalDeclaration();
        private List<VHDLComponent> m_components = new List<VHDLComponent>();
        private List<VHDLInstantiation> m_instantiation = new List<VHDLInstantiation>();
    }
}